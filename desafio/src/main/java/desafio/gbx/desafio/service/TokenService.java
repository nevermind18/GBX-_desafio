package desafio.gbx.desafio.service;import com.auth0.jwt.JWT;import com.auth0.jwt.JWTVerifier;import com.auth0.jwt.algorithms.Algorithm;import com.auth0.jwt.exceptions.JWTCreationException;import com.auth0.jwt.exceptions.JWTVerificationException;import desafio.gbx.desafio.entity.UsuarioEntity;import org.springframework.stereotype.Service;import java.time.Instant;import java.time.LocalDateTime;import java.time.ZoneOffset;import java.util.Date;@Servicepublic class TokenService {    public String geraToken(UsuarioEntity usuario){        try {            var algorithm = Algorithm.HMAC256("123456");            return JWT.create()                    .withIssuer("desafio")                    .withSubject(usuario.getNome())                    .withExpiresAt(dataExpiracao())                    .sign(algorithm);        }catch (JWTCreationException exception){            throw new RuntimeException("erro ao gerar token");        }    }    public String getSubject(String token){        try {            var algorithm = Algorithm.HMAC256("123456");            return JWT.require(algorithm)                    .withIssuer("desafio")                    .build()                    .verify(token)                    .getSubject();        }catch (JWTVerificationException e){            throw new RuntimeException("token invalido ou expirado");        }    }    private Instant dataExpiracao() {        return LocalDateTime.now().plusDays(1).toInstant(ZoneOffset.of("-03:00"));    }}