package desafio.gbx.desafio.service;import desafio.gbx.desafio.entity.TransacaoEntity;import desafio.gbx.desafio.entity.UsuarioEntity;import desafio.gbx.desafio.repository.TransacaoRepository;import org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.Mockito;import org.mockito.MockitoAnnotations;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.ResponseEntity;import java.time.LocalDateTime;import java.util.Optional;import static org.mockito.ArgumentMatchers.any;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;class TransacaoServiceTest {    @Mock    private TransacaoRepository transacaoRepository;    @Mock    private UsuarioService usuarioService;    @Autowired    @InjectMocks    TransacaoService transacaoService;    @BeforeEach    void setup(){        MockitoAnnotations.initMocks(this);    }    @Test    void criarTransacao() {        UsuarioEntity origem = new UsuarioEntity(1, "bruno", 1,5000);        UsuarioEntity destino = new UsuarioEntity(2, "gabi", 2,5000);        TransacaoEntity transacao = new TransacaoEntity(1,origem,destino,10, LocalDateTime.now());        when(usuarioService.existConta(1)).thenReturn(origem);        when(usuarioService.existConta(2)).thenReturn(destino);        when(transacaoRepository.save(transacao)).thenReturn(transacao);        Assertions.assertEquals(transacaoService.criarTransacao(transacao), ResponseEntity.ok(transacao));    }    @Test    void erroCriarTransacaoSaldoInsuficiente() {        ResponseEntity error = ResponseEntity.status(400).body("o saldo insuficiente");        UsuarioEntity origem = new UsuarioEntity(1, "bruno", 1,2);        UsuarioEntity destino = new UsuarioEntity(2, "gabi", 2,5000);        TransacaoEntity transacao = new TransacaoEntity(1,origem,destino,10, LocalDateTime.now());        when(usuarioService.existConta(1)).thenReturn(origem);        when(usuarioService.existConta(2)).thenReturn(destino);        when(transacaoRepository.save(transacao)).thenReturn(transacao);        Assertions.assertEquals(transacaoService.criarTransacao(transacao), error);    }    @Test    void erroCriarTransacaoContaDestinoInesistente() {        ResponseEntity error = ResponseEntity.status(404).body("conta de destino não existe");        UsuarioEntity origem = new UsuarioEntity(1, "bruno", 1,2);        UsuarioEntity destino = new UsuarioEntity(2, "gabi", 2,5000);        TransacaoEntity transacao = new TransacaoEntity(1,origem,destino,10, LocalDateTime.now());        when(usuarioService.existConta(1)).thenReturn(origem);        when(usuarioService.existConta(2)).thenReturn(null);        when(transacaoRepository.save(transacao)).thenReturn(transacao);        Assertions.assertEquals(transacaoService.criarTransacao(transacao), error);    }    @Test    void erroCriarTransacaoContaOrigemInesistente() {        ResponseEntity error = ResponseEntity.status(404).body("conta de origem não existe");        UsuarioEntity origem = new UsuarioEntity(1, "bruno", 1,2);        UsuarioEntity destino = new UsuarioEntity(2, "gabi", 2,5000);        TransacaoEntity transacao = new TransacaoEntity(1,origem,destino,10, LocalDateTime.now());        when(usuarioService.existConta(1)).thenReturn(null);        when(usuarioService.existConta(2)).thenReturn(destino);        when(transacaoRepository.save(transacao)).thenReturn(transacao);        Assertions.assertEquals(transacaoService.criarTransacao(transacao), error);    }    @Test    void consultaTransacao() {        UsuarioEntity origem = new UsuarioEntity(1, "bruno", 1,2);        UsuarioEntity destino = new UsuarioEntity(2, "gabi", 2,5000);        TransacaoEntity transacao = new TransacaoEntity(1,origem,destino,10, LocalDateTime.now());        when(transacaoRepository.findById(1L)).thenReturn(Optional.of(transacao));        Assertions.assertEquals(transacaoService.consultaTransacao(1), ResponseEntity.ok(transacao));    }}